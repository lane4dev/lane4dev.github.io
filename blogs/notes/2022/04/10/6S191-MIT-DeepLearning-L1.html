<!DOCTYPE html>
<html lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>深度学习基础 | lane4dev</title>
<meta name="generator" content="Jekyll v4.3.1">
<meta property="og:title" content="深度学习基础">
<meta name="author" content="Tang Yu">
<meta property="og:locale" content="zh">
<meta name="description" content="这篇文章是 6S191 MIT DeepLearning 系列课程第一课的笔记总结，我以原有课程内容为脉络，参考了李宏毅老师的课程和其他一些资料，在 Activation Function 的数学意义、 Backpropagation 过程的推导等这些自己感兴趣的话题作出了横向扩展，希望更进一步加深对深度学习的理解。深度学习在近些年发展迅速，而 MIT 6S191 DeepLearning 作为一门每年都会更新的介绍深度学习的入门类课程，在保持着极高的时效性同时，还拥有极高的课程质量，是不可多得的学习资料。 什么是 “深度学习” ？ 在文章的一开始需要理清楚几个基本的概念，分别是：“人工智能”、“机器学习” 和 “深度学习”。这几个概念在大众的认知中常常被有意或无意的混为一谈。 首先，人工智能 这一概念是 1956 年由约翰·麦卡锡等计算机科学家在 达特矛斯会议 上提出。由于意识到计算机科学巨大的发展潜力，当时的科学家提出了一种构想，即：是否有可以找到一种方法通过计算机来模拟人类的智力活动？多年后的今天，机器学习 对这个问题给出了其中一种答案。机器学习使用了统计学方法，针对特定问题，通过海量样本数据进行数学建模，发现这些数据的内在规律，并且利用发现的规律解决相似问题。而 深度学习 又是机器学习的一个分支，是以 人工神经网络 的架构对样本数据建模的一种方法。 从概念上来看，三者是相互包含的关系。“人工智能” 包含了 “机器学习”，“机器学习” 又包含了 “深度学习”。 为什么需要机器学习 传统计算机程序只能通过 if ... else 这样的条件判断，或是 for / while 这样的循环以一种线性的方式来处理问题。但是像是人脸识别、语音识别这一类的问题，没办法用传统的线性编程手段一步一步实现，我们迫切的需要一种新的算法来解决这些更加 “抽象” 的问题。 为什么是现在 互联网的爆炸式发展已经积累起海量数据，为机器学习的算法研究提供数据支撑 硬件的快速迭代，尤其是显卡算力的高速增长为机器学习的程序运算提供硬件支撑 配套软件诸如 scikit-learn 、pytorch、tenserflow 这样的支撑机器学习的软件已经比较成熟，为机器学习的程序运算提供了软件支撑 神经元（The Perceptron） 深度学习是基于对人类神经系统的模拟 关于人类大脑的神经网络是如何运作的，参考以下内容： TED Speech Sebastian Seung: I am my connectome Wikipedia: Computational neuroscience 神经元的数学表达 单个神经元由这样几部分组成： 输入、权重、求和函数、Activation Function 和 输出。 具体计算的过程是这样： 对 $m + 1$ 个输入 $x_0(x_0 = 1), x_1 … x_m$ 分别乘以各自的权重 $w_0, w_1 … w_m$ 把得到的结果通过求和函数相加 之后再传递给 Activation Function 最终得到一个输出 $\hat{y}$ 数学公式可以表达为： 用矩阵的方式来表示数学公式： 考虑激活函数后的完整式子 关于激活函数 激活函数事实上扮演了人类神经细胞之间信号传递时神经递质的作用。当电信号沿着突触从前一个神经细胞传递到下一个神经细胞时，在两者交界处，电信号转化成化学信号，前一个神经细胞释放的神经递质被下一个细胞接收，如果神经递质的量超过某个阈值就会引发下一个神经细胞的放电。使用激活函数也是类似的效果。 常见的激活函数有哪些？ 为什么要有激活函数？ 参考资料： Why Non-linear Activation Functions (C1W3L07) 要回答这个问题，不妨先换个思路。思考另一个问题： 如果没有激活函数会怎么样？ 对一个两层的神经网络，我们能得到以下公式： [\begin{align} &amp; \text Z^{[1]} = W^{[1]}x + b^{[1]} \\ &amp; \text a^{[1]} = g^{[1]}(Z^{[1]}) \\ &amp; \text Z^{[2]} = W^{[2]}x + b^{[2]} \\ &amp; \text a^{[2]} = g^{[2]}(Z^{[2]}) \\ \end{align}] 现在假设激活函数不存在，也即是在上面的式子中 $a^{[1]} = Z^{[1]}$ 和 $a^{[2]} = Z^{[2]}$ 又因为第一层是第二层的输入（ $a^{[1]}$ 等于 $a^{[2]}$ 式子中的输入 $x$ ），我们可以推导以下公式： [\begin{align} &amp; \text a^{[1]} = Z^{[1]} = W^{[1]}x + b^{[1]} \\ &amp; \text a^{[2]} = Z^{[2]} = W^{[2]}x + b^{[2]} \\ &amp; \text a^{[2]} = W^{[2]}(W^{[1]}x + b^{[1]}) + b^{[2]} \\ &amp; \text a^{[2]} = W^{[2]}W^{[1]}x + W^{[2]}b^{[1]} + b^{[2]} \\ \end{align}] 在上面的式子里，$W^{[2]}W^{[1]}$ 的结果可以用一个矩阵 $W^{[i]}$ 替代， $W^{[2]}b^{[1]} + b^{[2]}$ 的结果可以用另一个矩阵 $b^{[i]}$ 替代，于是就有了下面的式子： [a^{[2]} = W^{[i]}x = b^{[i]}] 通过以上推理过程能发现一个怎样的结论呢？ 如果没有激活函数，神经网络叠再多层都没有用，因为它始终都是线性的。 所以激活函数的作用就显而易见了： 激活函数的存在为神经网络的结构引入了非线性。让它能够通过一层一层的叠加来处理复杂问题。 为什么需要有一个 $w_0$ ？ 参考资料：Glossary of Deep Learning: Bias 从数学的角度理解 $w_{0}$ 被称为：bias ( 偏移 )。从数学上的解释来说，bias 的作用是激活函数能左右移动，以更好的拟合数据。 从更简单（更符合直觉）的角度理解 因为 bias 的存在，事实上决定了神经元在没有没有任何输入的情况下默认保持打开还是关闭的状态。 （或者这个神经元在多大程度上容易被打开，或容易被关闭） 所以 …… 这些 W 的权重是怎么算出来的？ 简单的答案是 Gradient Descent + Backpropagation，会在后面详细展开。 神经网络 神经元组成的网络 深度学习中的神经网络就是由这样一个一个单独神经元为基础不断叠加起来的 单层神经网络 深度（多层）神经网络 评估预测结果的准确性 我们使用 Loss Function $J(W)$ 在给定权重值 $W$ 的情况下评估模型预测的准确性。有以下几种不同的评估方式： Quantifying Loss 旨在预测出错时衡量预测值与实际值之间的偏差。 Empirical Loss 衡量所有数据中预测值与实际值之间的偏差。 Binary Cross Entropy Loss 当模型预测的结果是 0 到 1 之间的概率时，用 Binary Cross Entropy Loss 衡量预测准确性 。 Mean Squared Error Loss 一般用 Mean squared error loss 评价输出是连续值的回归类模型中实际值与预测值之间的差异。 训练神经网络 在前一部分的内容里，在假定权重 $W$ 的值已经确定的条件下介绍了神经网络的结构以及如何评估预测结果的准确性。 在这一部分会重点关注神经网络中的权重 $W$ 是如何产生的。 理论上，我们需要找到这样一个 $W$ ，使得它在所有的数据集的预测结果上损失最小 如果可以把所有 $W$ 组合下对应的损失函数的值分布绘制出来，很直观的就能发现最小损失函数对应的 $w$ 值是多少（下图示范了只有两个 $w$ 的情况下情况下损失函数值域分布图 ） Gradient Descent 在实际应用场景里，一个普通的神经网路结构，轻轻松松就能包含上万个 $w$ 参数。想要穷举所有 $w$ 的组合即使对于现代计算机而言也是绝无可能的。更实际的做法是使用名为 Gradient Descent 的方法，思路是这样的： 在一开始随机给定 $W$ 初始值 对每一个 $w_i$ 分别计算它对损失函数 $J(W)$ 的斜率，也就是计算 $\frac{\partial J(W)}{\partial w_i}$ 在使 $J(W)$ 总体变小的方向上选定一个步长 $\eta$ 来更新 $w_i$ 的值，然后前进到下一个点 重复以上步骤，直到 $\frac{\partial J(W)}{\partial W}$ 收敛，此时斜率为零，达到值局部最小的位置。 Gradient Descent 的算法描述为 Backpropagation 参考资料： Backpropagation Understanding Backpropagation Algorithm Neural Networks from Scratch 接下来关注 $\frac{\partial J(W)}{\partial W}$ 具体的计算过程，在这个过程中使用了一种叫 Backpropagation 的方法【 Backpropagation 是机器之所以能够 “学习” 的核心，因此需要重点掌握 】。 公式推导过程 考虑下面这样一个经过简化后的神经网络模型： 在这个模型中，输入为 $x_1$ 和 $x_2$，预测结果为 $y_1$ 和 $y_2$。实际的真实值为 $T_1$ 和 $T_2$ 。Activation Function 使用 Sigmoid 函数 $g(x) = \frac{1}{1 + e^{-x}}$。 Loss Function 使用 Mean squared error loss： $J(W) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - f(x^{(i)}, W))^2$。 在推导公式之前，先复习一下 Chain Rule ： 首先，从正向来看： [\begin{align} &amp; \text y_1 = g( z_{2,1} ) = g( g( z_{1,1} ) \times w_5 + g( z_{1,2} ) \times w_6 ) \\ &amp; \text y_1 = g( g( x_1 \times w_1 + x_2 \times w_2 ) \times w_5 + g( x_1 \times w_3 + x_2 \times w_4 ) \times w_6 ) \\ &amp; \text {} \\ &amp; \text y_2 = g( z_{2,2} ) = g( g( z_{1,1} ) \times w_7 + g( z_{1,2} ) \times w_8 ) \\ &amp; \text y_2 = g( g( x_1 \times w_1 + x_2 \times w_2 ) \times w_7 + g( x_1 \times w_3 + x_2 \times w_4 ) \times w_8 ) \\ \end{align}] 因此可以很容易得到 Loss Function $J(W)$： [\begin{align} &amp; \text J(W) = \frac{1}{2} (T_1 - y_1)^2 + \frac{1}{2} (T_2 - y_2)^2 \end{align}] 接下来，先求 $\frac{\partial J(W)}{w_5}$，由 chain Rule 可得： [\begin{align} &amp; \text {} \frac{\partial J(W)}{\partial w_5} = \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial Z_(2,1)} \times \frac{\partial Z_(2,1)}{\partial w_5} \\ &amp; \text {} \frac{\partial J(W)}{\partial w_5} = ( y_1 - T_1 ) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times g(Z_{1,1}) \\ \end{align}] 同理，可求得 $\frac{\partial J(W)}{w_6}$、 $\frac{\partial J(W)}{w_7}$、 $\frac{\partial J(W)}{w_8}$ 。 接下来，再求 $\frac{\partial (W)}{w_1}$，由 chain Rule 可得： [\begin{align} &amp; \text {} \frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial Z_{1,1}} \times \frac{\partial Z_{1,1}}{\partial w_1} \\ &amp; \text {} \frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial g(Z_{1,1})} \times \frac{\partial g(Z_{1,1})}{\partial Z_{1,1}} \times \frac{\partial Z_{1,1}}{\partial w_1} \\ \end{align}] 其中： [\begin{align} \text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial g(Z_{1,1})} \\ &amp;+ \frac{\partial J(W)}{\partial y_2} \times \frac{\partial y_2}{\partial g(Z_{1,1})} \\ {} \\ \text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial Z_{2,1}} \times \frac{\partial Z_{2,1}}{\partial g(Z_{1,1})} \\ &amp;+ \frac{\partial J(W)}{\partial y_2} \times \frac{\partial y_2}{\partial Z_{2,2}} \times \frac{\partial Z_{2,2}}{\partial g(Z_{1,1})} \\ {} \\ \text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= (y_1 - T_1) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times w_5 \\ &amp;+ (y_2 - T_2) \times g(Z_{2,2}) \times (1 - g(Z_{2,2})) \times w_7 \\ \end{align}] 最终合在一起就是： [\begin{align} \text {} \frac{\partial J(W)}{\partial w_1} &amp;= ((y_1 - T_1) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times w_5 \\ &amp; + (y_2 - T_2) \times g(Z_{2,2}) \times (1 - g(Z_{2,2})) \times w_7) \times g(Z_{1,1}) \times (1 - g(Z_{1,1})) \times x_1) \end{align}] 同理，可求得 $\frac{\partial J(W)}{w_2}$、 $\frac{\partial J(W)}{w_3}$、 $\frac{\partial J(W)}{w_4}$ 。 事实上，对于任意一个神经元节点来说： 都有： [\begin{align} &amp; \text {} \frac{\partial J(W)}{\partial Z_{t,i}} = g(Z_{t,i}) \times \sum_{k=i}^{j} w_{t+1, k} \frac{\partial J(W)}{\partial Z_{t+1,k}} \\ \end{align}] 这也就是为什么这个操作叫 Backpropagation 的原因。 Python 代码实现 以下是使用 Python 代码重现了 Backpropagation 的过程。 import numpy as np def sigmoid(a): return 1 / (1 + np.exp(-a)) def diff_sigmoid(a): return ( 1 - sigmoid(a)) * sigmoid(a) def loss_function(actual, predict): return np.sum( ( ( actual - predict ) ** 2 ) / 2 ) def p_JW_of_H(layer, row_num): if layer == max_layer: return (y[row_num] - t[row_num]) * diff_sigmoid(A[layer - 1][row_num]) else: out = 0 m = A[layer - 1].shape[0] for i in range(m): out += p_JW_of_H(layer+1, row_num) * W[layer][row_num, i] * diff_sigmoid(A[layer - 1][row_num]) return out def p_JW_of_W(row_num, col_num, layer): return p_JW_of_H(layer, row_num) * X[layer - 1][col_num] x1 = np.array([[0.05], [0.10]]) w1 = np.array([[0.15, 0.20], [0.25, 0.30]]) a1 = w1.dot(x1) x2 = sigmoid(a1) w2 = np.array([[0.40, 0.45], [0.50, 0.55]]) a2 = w2.dot(x2) y = sigmoid(a2) t = np.array([0.01, 0.99]) X = [x1, x2] A = [a1, a2] W = [w1, w2] eta = 0.01 for _ in range(10000): for l in range(len(X)): for r in range(W[l].shape[0]): for c in range(W[l].shape[1]): W[l][r, c] = W[l][r, c] - eta * p_JW_of_W(r, c, l + 1) A[0] = W[0].dot(X[0]) X[1] = sigmoid(A[0]) A[1] = W[1].dot(X[1]) y = sigmoid(A[1]) 神经网络优化实践 现实中的神经网络训练往往是一个很让人头疼的问题，抛开数据量很大，计算复杂这一点。另一方面的问题是在 Gradient Descent 算法中步长 $\eta$ 选择上。选择的步长过大，会导致结果轻易越过 W 的局部最优，离预期差十万八千里。选择的步长过小，会导致每一次的迭代中 W 的值几乎没有变化，需要浪费大量的时间和计算资源才能得到预期结果。 针对这一问题，最先想到的解决办法自然就是尝试不同的步长值，试出一种时间和计算资源成本不高且最终结果良好的步长值。采用这种方式的一个最主要的问题是缺乏通用性，每一次训练新的模型都需要经历同样的试验步长的步骤。 另一种可能的解决办法是不使用固定的步长，而是根据 Gradient 的大小、学习时间的长短、权重 W 的数量等因素设计一套算法，能够在每次迭代过程中自动选择最佳步长。实际上，类似 tensorflow 这样的框架里已经集成了一些实现上述目标的算法，像是：SGD、 Adam、 Adadelta 等等。 Mini-batches 正如同前面提到的，现实中使用的神经网络结构一般都十分复杂。要在百万次级别的迭代中计算全部数据的 Loss Function J(W) 对权重 W 的偏微分是一件极其困难的事。换个角度讲，也可以说是一件极其低效率的事，毕竟在每一次的迭代中我们期望的实际上是权重 W 向理想中的值靠近一点点。那么，更 “经济” 的做法是使用 Stochastic Gradient Descent，也就是说，每次从训练的样本中随机挑选 n 个，计算这些样本 Gradient 的平均值，将得到的平均值带入后续的计算中，指导权重 W 的更新。 过拟合的问题 所谓的过拟合，是指模型结构过于复杂，在对训练样本的预测结果变现异常完美，但面对新数据时却表现的一塌糊涂。 解决这个问题有两种思路，一种方法是 Dropout，在每次迭代的过程中随机将部分（一般是 50%） 中间隐藏层神经元的输出设置为零，以此来避免其中单独某一个节点对输出结果产生决定性影响。 另一种方法是 Early Stopping，也就是在过拟合问题出现之前提前停止训练。在每次训练过程中，把数据按比例（通常是 4:1）拆分成两部分：训练数据和测试数据，测试数据不参与训练，只用于验证模型训练结果。在每一次的迭代中观察模型对训练数据和测试数据的表现，如果在某一时刻模型对训练数据 Loss 保持降低的同时对测试数据 Loss 有上升的趋势，说明模型可能开始出现过拟合，应该在此时停止训练。 总结 这是 6S191 系列课程的第一节课，主要简单介绍了深度学习技术的一些基础知识，包括神经元及其数学表达、神经网络如何搭建如何训练，最后围绕实际生产环境中如何提升模型训练效率和准确度的问题提供了若干解决思路。">
<meta property="og:description" content="这篇文章是 6S191 MIT DeepLearning 系列课程第一课的笔记总结，我以原有课程内容为脉络，参考了李宏毅老师的课程和其他一些资料，在 Activation Function 的数学意义、 Backpropagation 过程的推导等这些自己感兴趣的话题作出了横向扩展，希望更进一步加深对深度学习的理解。深度学习在近些年发展迅速，而 MIT 6S191 DeepLearning 作为一门每年都会更新的介绍深度学习的入门类课程，在保持着极高的时效性同时，还拥有极高的课程质量，是不可多得的学习资料。 什么是 “深度学习” ？ 在文章的一开始需要理清楚几个基本的概念，分别是：“人工智能”、“机器学习” 和 “深度学习”。这几个概念在大众的认知中常常被有意或无意的混为一谈。 首先，人工智能 这一概念是 1956 年由约翰·麦卡锡等计算机科学家在 达特矛斯会议 上提出。由于意识到计算机科学巨大的发展潜力，当时的科学家提出了一种构想，即：是否有可以找到一种方法通过计算机来模拟人类的智力活动？多年后的今天，机器学习 对这个问题给出了其中一种答案。机器学习使用了统计学方法，针对特定问题，通过海量样本数据进行数学建模，发现这些数据的内在规律，并且利用发现的规律解决相似问题。而 深度学习 又是机器学习的一个分支，是以 人工神经网络 的架构对样本数据建模的一种方法。 从概念上来看，三者是相互包含的关系。“人工智能” 包含了 “机器学习”，“机器学习” 又包含了 “深度学习”。 为什么需要机器学习 传统计算机程序只能通过 if ... else 这样的条件判断，或是 for / while 这样的循环以一种线性的方式来处理问题。但是像是人脸识别、语音识别这一类的问题，没办法用传统的线性编程手段一步一步实现，我们迫切的需要一种新的算法来解决这些更加 “抽象” 的问题。 为什么是现在 互联网的爆炸式发展已经积累起海量数据，为机器学习的算法研究提供数据支撑 硬件的快速迭代，尤其是显卡算力的高速增长为机器学习的程序运算提供硬件支撑 配套软件诸如 scikit-learn 、pytorch、tenserflow 这样的支撑机器学习的软件已经比较成熟，为机器学习的程序运算提供了软件支撑 神经元（The Perceptron） 深度学习是基于对人类神经系统的模拟 关于人类大脑的神经网络是如何运作的，参考以下内容： TED Speech Sebastian Seung: I am my connectome Wikipedia: Computational neuroscience 神经元的数学表达 单个神经元由这样几部分组成： 输入、权重、求和函数、Activation Function 和 输出。 具体计算的过程是这样： 对 $m + 1$ 个输入 $x_0(x_0 = 1), x_1 … x_m$ 分别乘以各自的权重 $w_0, w_1 … w_m$ 把得到的结果通过求和函数相加 之后再传递给 Activation Function 最终得到一个输出 $\hat{y}$ 数学公式可以表达为： 用矩阵的方式来表示数学公式： 考虑激活函数后的完整式子 关于激活函数 激活函数事实上扮演了人类神经细胞之间信号传递时神经递质的作用。当电信号沿着突触从前一个神经细胞传递到下一个神经细胞时，在两者交界处，电信号转化成化学信号，前一个神经细胞释放的神经递质被下一个细胞接收，如果神经递质的量超过某个阈值就会引发下一个神经细胞的放电。使用激活函数也是类似的效果。 常见的激活函数有哪些？ 为什么要有激活函数？ 参考资料： Why Non-linear Activation Functions (C1W3L07) 要回答这个问题，不妨先换个思路。思考另一个问题： 如果没有激活函数会怎么样？ 对一个两层的神经网络，我们能得到以下公式： [\begin{align} &amp; \text Z^{[1]} = W^{[1]}x + b^{[1]} \\ &amp; \text a^{[1]} = g^{[1]}(Z^{[1]}) \\ &amp; \text Z^{[2]} = W^{[2]}x + b^{[2]} \\ &amp; \text a^{[2]} = g^{[2]}(Z^{[2]}) \\ \end{align}] 现在假设激活函数不存在，也即是在上面的式子中 $a^{[1]} = Z^{[1]}$ 和 $a^{[2]} = Z^{[2]}$ 又因为第一层是第二层的输入（ $a^{[1]}$ 等于 $a^{[2]}$ 式子中的输入 $x$ ），我们可以推导以下公式： [\begin{align} &amp; \text a^{[1]} = Z^{[1]} = W^{[1]}x + b^{[1]} \\ &amp; \text a^{[2]} = Z^{[2]} = W^{[2]}x + b^{[2]} \\ &amp; \text a^{[2]} = W^{[2]}(W^{[1]}x + b^{[1]}) + b^{[2]} \\ &amp; \text a^{[2]} = W^{[2]}W^{[1]}x + W^{[2]}b^{[1]} + b^{[2]} \\ \end{align}] 在上面的式子里，$W^{[2]}W^{[1]}$ 的结果可以用一个矩阵 $W^{[i]}$ 替代， $W^{[2]}b^{[1]} + b^{[2]}$ 的结果可以用另一个矩阵 $b^{[i]}$ 替代，于是就有了下面的式子： [a^{[2]} = W^{[i]}x = b^{[i]}] 通过以上推理过程能发现一个怎样的结论呢？ 如果没有激活函数，神经网络叠再多层都没有用，因为它始终都是线性的。 所以激活函数的作用就显而易见了： 激活函数的存在为神经网络的结构引入了非线性。让它能够通过一层一层的叠加来处理复杂问题。 为什么需要有一个 $w_0$ ？ 参考资料：Glossary of Deep Learning: Bias 从数学的角度理解 $w_{0}$ 被称为：bias ( 偏移 )。从数学上的解释来说，bias 的作用是激活函数能左右移动，以更好的拟合数据。 从更简单（更符合直觉）的角度理解 因为 bias 的存在，事实上决定了神经元在没有没有任何输入的情况下默认保持打开还是关闭的状态。 （或者这个神经元在多大程度上容易被打开，或容易被关闭） 所以 …… 这些 W 的权重是怎么算出来的？ 简单的答案是 Gradient Descent + Backpropagation，会在后面详细展开。 神经网络 神经元组成的网络 深度学习中的神经网络就是由这样一个一个单独神经元为基础不断叠加起来的 单层神经网络 深度（多层）神经网络 评估预测结果的准确性 我们使用 Loss Function $J(W)$ 在给定权重值 $W$ 的情况下评估模型预测的准确性。有以下几种不同的评估方式： Quantifying Loss 旨在预测出错时衡量预测值与实际值之间的偏差。 Empirical Loss 衡量所有数据中预测值与实际值之间的偏差。 Binary Cross Entropy Loss 当模型预测的结果是 0 到 1 之间的概率时，用 Binary Cross Entropy Loss 衡量预测准确性 。 Mean Squared Error Loss 一般用 Mean squared error loss 评价输出是连续值的回归类模型中实际值与预测值之间的差异。 训练神经网络 在前一部分的内容里，在假定权重 $W$ 的值已经确定的条件下介绍了神经网络的结构以及如何评估预测结果的准确性。 在这一部分会重点关注神经网络中的权重 $W$ 是如何产生的。 理论上，我们需要找到这样一个 $W$ ，使得它在所有的数据集的预测结果上损失最小 如果可以把所有 $W$ 组合下对应的损失函数的值分布绘制出来，很直观的就能发现最小损失函数对应的 $w$ 值是多少（下图示范了只有两个 $w$ 的情况下情况下损失函数值域分布图 ） Gradient Descent 在实际应用场景里，一个普通的神经网路结构，轻轻松松就能包含上万个 $w$ 参数。想要穷举所有 $w$ 的组合即使对于现代计算机而言也是绝无可能的。更实际的做法是使用名为 Gradient Descent 的方法，思路是这样的： 在一开始随机给定 $W$ 初始值 对每一个 $w_i$ 分别计算它对损失函数 $J(W)$ 的斜率，也就是计算 $\frac{\partial J(W)}{\partial w_i}$ 在使 $J(W)$ 总体变小的方向上选定一个步长 $\eta$ 来更新 $w_i$ 的值，然后前进到下一个点 重复以上步骤，直到 $\frac{\partial J(W)}{\partial W}$ 收敛，此时斜率为零，达到值局部最小的位置。 Gradient Descent 的算法描述为 Backpropagation 参考资料： Backpropagation Understanding Backpropagation Algorithm Neural Networks from Scratch 接下来关注 $\frac{\partial J(W)}{\partial W}$ 具体的计算过程，在这个过程中使用了一种叫 Backpropagation 的方法【 Backpropagation 是机器之所以能够 “学习” 的核心，因此需要重点掌握 】。 公式推导过程 考虑下面这样一个经过简化后的神经网络模型： 在这个模型中，输入为 $x_1$ 和 $x_2$，预测结果为 $y_1$ 和 $y_2$。实际的真实值为 $T_1$ 和 $T_2$ 。Activation Function 使用 Sigmoid 函数 $g(x) = \frac{1}{1 + e^{-x}}$。 Loss Function 使用 Mean squared error loss： $J(W) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - f(x^{(i)}, W))^2$。 在推导公式之前，先复习一下 Chain Rule ： 首先，从正向来看： [\begin{align} &amp; \text y_1 = g( z_{2,1} ) = g( g( z_{1,1} ) \times w_5 + g( z_{1,2} ) \times w_6 ) \\ &amp; \text y_1 = g( g( x_1 \times w_1 + x_2 \times w_2 ) \times w_5 + g( x_1 \times w_3 + x_2 \times w_4 ) \times w_6 ) \\ &amp; \text {} \\ &amp; \text y_2 = g( z_{2,2} ) = g( g( z_{1,1} ) \times w_7 + g( z_{1,2} ) \times w_8 ) \\ &amp; \text y_2 = g( g( x_1 \times w_1 + x_2 \times w_2 ) \times w_7 + g( x_1 \times w_3 + x_2 \times w_4 ) \times w_8 ) \\ \end{align}] 因此可以很容易得到 Loss Function $J(W)$： [\begin{align} &amp; \text J(W) = \frac{1}{2} (T_1 - y_1)^2 + \frac{1}{2} (T_2 - y_2)^2 \end{align}] 接下来，先求 $\frac{\partial J(W)}{w_5}$，由 chain Rule 可得： [\begin{align} &amp; \text {} \frac{\partial J(W)}{\partial w_5} = \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial Z_(2,1)} \times \frac{\partial Z_(2,1)}{\partial w_5} \\ &amp; \text {} \frac{\partial J(W)}{\partial w_5} = ( y_1 - T_1 ) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times g(Z_{1,1}) \\ \end{align}] 同理，可求得 $\frac{\partial J(W)}{w_6}$、 $\frac{\partial J(W)}{w_7}$、 $\frac{\partial J(W)}{w_8}$ 。 接下来，再求 $\frac{\partial (W)}{w_1}$，由 chain Rule 可得： [\begin{align} &amp; \text {} \frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial Z_{1,1}} \times \frac{\partial Z_{1,1}}{\partial w_1} \\ &amp; \text {} \frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial g(Z_{1,1})} \times \frac{\partial g(Z_{1,1})}{\partial Z_{1,1}} \times \frac{\partial Z_{1,1}}{\partial w_1} \\ \end{align}] 其中： [\begin{align} \text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial g(Z_{1,1})} \\ &amp;+ \frac{\partial J(W)}{\partial y_2} \times \frac{\partial y_2}{\partial g(Z_{1,1})} \\ {} \\ \text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial Z_{2,1}} \times \frac{\partial Z_{2,1}}{\partial g(Z_{1,1})} \\ &amp;+ \frac{\partial J(W)}{\partial y_2} \times \frac{\partial y_2}{\partial Z_{2,2}} \times \frac{\partial Z_{2,2}}{\partial g(Z_{1,1})} \\ {} \\ \text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= (y_1 - T_1) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times w_5 \\ &amp;+ (y_2 - T_2) \times g(Z_{2,2}) \times (1 - g(Z_{2,2})) \times w_7 \\ \end{align}] 最终合在一起就是： [\begin{align} \text {} \frac{\partial J(W)}{\partial w_1} &amp;= ((y_1 - T_1) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times w_5 \\ &amp; + (y_2 - T_2) \times g(Z_{2,2}) \times (1 - g(Z_{2,2})) \times w_7) \times g(Z_{1,1}) \times (1 - g(Z_{1,1})) \times x_1) \end{align}] 同理，可求得 $\frac{\partial J(W)}{w_2}$、 $\frac{\partial J(W)}{w_3}$、 $\frac{\partial J(W)}{w_4}$ 。 事实上，对于任意一个神经元节点来说： 都有： [\begin{align} &amp; \text {} \frac{\partial J(W)}{\partial Z_{t,i}} = g(Z_{t,i}) \times \sum_{k=i}^{j} w_{t+1, k} \frac{\partial J(W)}{\partial Z_{t+1,k}} \\ \end{align}] 这也就是为什么这个操作叫 Backpropagation 的原因。 Python 代码实现 以下是使用 Python 代码重现了 Backpropagation 的过程。 import numpy as np def sigmoid(a): return 1 / (1 + np.exp(-a)) def diff_sigmoid(a): return ( 1 - sigmoid(a)) * sigmoid(a) def loss_function(actual, predict): return np.sum( ( ( actual - predict ) ** 2 ) / 2 ) def p_JW_of_H(layer, row_num): if layer == max_layer: return (y[row_num] - t[row_num]) * diff_sigmoid(A[layer - 1][row_num]) else: out = 0 m = A[layer - 1].shape[0] for i in range(m): out += p_JW_of_H(layer+1, row_num) * W[layer][row_num, i] * diff_sigmoid(A[layer - 1][row_num]) return out def p_JW_of_W(row_num, col_num, layer): return p_JW_of_H(layer, row_num) * X[layer - 1][col_num] x1 = np.array([[0.05], [0.10]]) w1 = np.array([[0.15, 0.20], [0.25, 0.30]]) a1 = w1.dot(x1) x2 = sigmoid(a1) w2 = np.array([[0.40, 0.45], [0.50, 0.55]]) a2 = w2.dot(x2) y = sigmoid(a2) t = np.array([0.01, 0.99]) X = [x1, x2] A = [a1, a2] W = [w1, w2] eta = 0.01 for _ in range(10000): for l in range(len(X)): for r in range(W[l].shape[0]): for c in range(W[l].shape[1]): W[l][r, c] = W[l][r, c] - eta * p_JW_of_W(r, c, l + 1) A[0] = W[0].dot(X[0]) X[1] = sigmoid(A[0]) A[1] = W[1].dot(X[1]) y = sigmoid(A[1]) 神经网络优化实践 现实中的神经网络训练往往是一个很让人头疼的问题，抛开数据量很大，计算复杂这一点。另一方面的问题是在 Gradient Descent 算法中步长 $\eta$ 选择上。选择的步长过大，会导致结果轻易越过 W 的局部最优，离预期差十万八千里。选择的步长过小，会导致每一次的迭代中 W 的值几乎没有变化，需要浪费大量的时间和计算资源才能得到预期结果。 针对这一问题，最先想到的解决办法自然就是尝试不同的步长值，试出一种时间和计算资源成本不高且最终结果良好的步长值。采用这种方式的一个最主要的问题是缺乏通用性，每一次训练新的模型都需要经历同样的试验步长的步骤。 另一种可能的解决办法是不使用固定的步长，而是根据 Gradient 的大小、学习时间的长短、权重 W 的数量等因素设计一套算法，能够在每次迭代过程中自动选择最佳步长。实际上，类似 tensorflow 这样的框架里已经集成了一些实现上述目标的算法，像是：SGD、 Adam、 Adadelta 等等。 Mini-batches 正如同前面提到的，现实中使用的神经网络结构一般都十分复杂。要在百万次级别的迭代中计算全部数据的 Loss Function J(W) 对权重 W 的偏微分是一件极其困难的事。换个角度讲，也可以说是一件极其低效率的事，毕竟在每一次的迭代中我们期望的实际上是权重 W 向理想中的值靠近一点点。那么，更 “经济” 的做法是使用 Stochastic Gradient Descent，也就是说，每次从训练的样本中随机挑选 n 个，计算这些样本 Gradient 的平均值，将得到的平均值带入后续的计算中，指导权重 W 的更新。 过拟合的问题 所谓的过拟合，是指模型结构过于复杂，在对训练样本的预测结果变现异常完美，但面对新数据时却表现的一塌糊涂。 解决这个问题有两种思路，一种方法是 Dropout，在每次迭代的过程中随机将部分（一般是 50%） 中间隐藏层神经元的输出设置为零，以此来避免其中单独某一个节点对输出结果产生决定性影响。 另一种方法是 Early Stopping，也就是在过拟合问题出现之前提前停止训练。在每次训练过程中，把数据按比例（通常是 4:1）拆分成两部分：训练数据和测试数据，测试数据不参与训练，只用于验证模型训练结果。在每一次的迭代中观察模型对训练数据和测试数据的表现，如果在某一时刻模型对训练数据 Loss 保持降低的同时对测试数据 Loss 有上升的趋势，说明模型可能开始出现过拟合，应该在此时停止训练。 总结 这是 6S191 系列课程的第一节课，主要简单介绍了深度学习技术的一些基础知识，包括神经元及其数学表达、神经网络如何搭建如何训练，最后围绕实际生产环境中如何提升模型训练效率和准确度的问题提供了若干解决思路。">
<link rel="canonical" href="/blogs/notes/2022/04/10/6S191-MIT-DeepLearning-L1.html">
<meta property="og:url" content="/blogs/notes/2022/04/10/6S191-MIT-DeepLearning-L1.html">
<meta property="og:site_name" content="lane4dev">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-04-10T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="深度学习基础">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Tang Yu"},"dateModified":"2022-04-10T00:00:00+00:00","datePublished":"2022-04-10T00:00:00+00:00","description":"这篇文章是 6S191 MIT DeepLearning 系列课程第一课的笔记总结，我以原有课程内容为脉络，参考了李宏毅老师的课程和其他一些资料，在 Activation Function 的数学意义、 Backpropagation 过程的推导等这些自己感兴趣的话题作出了横向扩展，希望更进一步加深对深度学习的理解。深度学习在近些年发展迅速，而 MIT 6S191 DeepLearning 作为一门每年都会更新的介绍深度学习的入门类课程，在保持着极高的时效性同时，还拥有极高的课程质量，是不可多得的学习资料。 什么是 “深度学习” ？ 在文章的一开始需要理清楚几个基本的概念，分别是：“人工智能”、“机器学习” 和 “深度学习”。这几个概念在大众的认知中常常被有意或无意的混为一谈。 首先，人工智能 这一概念是 1956 年由约翰·麦卡锡等计算机科学家在 达特矛斯会议 上提出。由于意识到计算机科学巨大的发展潜力，当时的科学家提出了一种构想，即：是否有可以找到一种方法通过计算机来模拟人类的智力活动？多年后的今天，机器学习 对这个问题给出了其中一种答案。机器学习使用了统计学方法，针对特定问题，通过海量样本数据进行数学建模，发现这些数据的内在规律，并且利用发现的规律解决相似问题。而 深度学习 又是机器学习的一个分支，是以 人工神经网络 的架构对样本数据建模的一种方法。 从概念上来看，三者是相互包含的关系。“人工智能” 包含了 “机器学习”，“机器学习” 又包含了 “深度学习”。 为什么需要机器学习 传统计算机程序只能通过 if ... else 这样的条件判断，或是 for / while 这样的循环以一种线性的方式来处理问题。但是像是人脸识别、语音识别这一类的问题，没办法用传统的线性编程手段一步一步实现，我们迫切的需要一种新的算法来解决这些更加 “抽象” 的问题。 为什么是现在 互联网的爆炸式发展已经积累起海量数据，为机器学习的算法研究提供数据支撑 硬件的快速迭代，尤其是显卡算力的高速增长为机器学习的程序运算提供硬件支撑 配套软件诸如 scikit-learn 、pytorch、tenserflow 这样的支撑机器学习的软件已经比较成熟，为机器学习的程序运算提供了软件支撑 神经元（The Perceptron） 深度学习是基于对人类神经系统的模拟 关于人类大脑的神经网络是如何运作的，参考以下内容： TED Speech Sebastian Seung: I am my connectome Wikipedia: Computational neuroscience 神经元的数学表达 单个神经元由这样几部分组成： 输入、权重、求和函数、Activation Function 和 输出。 具体计算的过程是这样： 对 $m + 1$ 个输入 $x_0(x_0 = 1), x_1 … x_m$ 分别乘以各自的权重 $w_0, w_1 … w_m$ 把得到的结果通过求和函数相加 之后再传递给 Activation Function 最终得到一个输出 $\\hat{y}$ 数学公式可以表达为： 用矩阵的方式来表示数学公式： 考虑激活函数后的完整式子 关于激活函数 激活函数事实上扮演了人类神经细胞之间信号传递时神经递质的作用。当电信号沿着突触从前一个神经细胞传递到下一个神经细胞时，在两者交界处，电信号转化成化学信号，前一个神经细胞释放的神经递质被下一个细胞接收，如果神经递质的量超过某个阈值就会引发下一个神经细胞的放电。使用激活函数也是类似的效果。 常见的激活函数有哪些？ 为什么要有激活函数？ 参考资料： Why Non-linear Activation Functions (C1W3L07) 要回答这个问题，不妨先换个思路。思考另一个问题： 如果没有激活函数会怎么样？ 对一个两层的神经网络，我们能得到以下公式： [\\begin{align} &amp; \\text Z^{[1]} = W^{[1]}x + b^{[1]} \\\\ &amp; \\text a^{[1]} = g^{[1]}(Z^{[1]}) \\\\ &amp; \\text Z^{[2]} = W^{[2]}x + b^{[2]} \\\\ &amp; \\text a^{[2]} = g^{[2]}(Z^{[2]}) \\\\ \\end{align}] 现在假设激活函数不存在，也即是在上面的式子中 $a^{[1]} = Z^{[1]}$ 和 $a^{[2]} = Z^{[2]}$ 又因为第一层是第二层的输入（ $a^{[1]}$ 等于 $a^{[2]}$ 式子中的输入 $x$ ），我们可以推导以下公式： [\\begin{align} &amp; \\text a^{[1]} = Z^{[1]} = W^{[1]}x + b^{[1]} \\\\ &amp; \\text a^{[2]} = Z^{[2]} = W^{[2]}x + b^{[2]} \\\\ &amp; \\text a^{[2]} = W^{[2]}(W^{[1]}x + b^{[1]}) + b^{[2]} \\\\ &amp; \\text a^{[2]} = W^{[2]}W^{[1]}x + W^{[2]}b^{[1]} + b^{[2]} \\\\ \\end{align}] 在上面的式子里，$W^{[2]}W^{[1]}$ 的结果可以用一个矩阵 $W^{[i]}$ 替代， $W^{[2]}b^{[1]} + b^{[2]}$ 的结果可以用另一个矩阵 $b^{[i]}$ 替代，于是就有了下面的式子： [a^{[2]} = W^{[i]}x = b^{[i]}] 通过以上推理过程能发现一个怎样的结论呢？ 如果没有激活函数，神经网络叠再多层都没有用，因为它始终都是线性的。 所以激活函数的作用就显而易见了： 激活函数的存在为神经网络的结构引入了非线性。让它能够通过一层一层的叠加来处理复杂问题。 为什么需要有一个 $w_0$ ？ 参考资料：Glossary of Deep Learning: Bias 从数学的角度理解 $w_{0}$ 被称为：bias ( 偏移 )。从数学上的解释来说，bias 的作用是激活函数能左右移动，以更好的拟合数据。 从更简单（更符合直觉）的角度理解 因为 bias 的存在，事实上决定了神经元在没有没有任何输入的情况下默认保持打开还是关闭的状态。 （或者这个神经元在多大程度上容易被打开，或容易被关闭） 所以 …… 这些 W 的权重是怎么算出来的？ 简单的答案是 Gradient Descent + Backpropagation，会在后面详细展开。 神经网络 神经元组成的网络 深度学习中的神经网络就是由这样一个一个单独神经元为基础不断叠加起来的 单层神经网络 深度（多层）神经网络 评估预测结果的准确性 我们使用 Loss Function $J(W)$ 在给定权重值 $W$ 的情况下评估模型预测的准确性。有以下几种不同的评估方式： Quantifying Loss 旨在预测出错时衡量预测值与实际值之间的偏差。 Empirical Loss 衡量所有数据中预测值与实际值之间的偏差。 Binary Cross Entropy Loss 当模型预测的结果是 0 到 1 之间的概率时，用 Binary Cross Entropy Loss 衡量预测准确性 。 Mean Squared Error Loss 一般用 Mean squared error loss 评价输出是连续值的回归类模型中实际值与预测值之间的差异。 训练神经网络 在前一部分的内容里，在假定权重 $W$ 的值已经确定的条件下介绍了神经网络的结构以及如何评估预测结果的准确性。 在这一部分会重点关注神经网络中的权重 $W$ 是如何产生的。 理论上，我们需要找到这样一个 $W$ ，使得它在所有的数据集的预测结果上损失最小 如果可以把所有 $W$ 组合下对应的损失函数的值分布绘制出来，很直观的就能发现最小损失函数对应的 $w$ 值是多少（下图示范了只有两个 $w$ 的情况下情况下损失函数值域分布图 ） Gradient Descent 在实际应用场景里，一个普通的神经网路结构，轻轻松松就能包含上万个 $w$ 参数。想要穷举所有 $w$ 的组合即使对于现代计算机而言也是绝无可能的。更实际的做法是使用名为 Gradient Descent 的方法，思路是这样的： 在一开始随机给定 $W$ 初始值 对每一个 $w_i$ 分别计算它对损失函数 $J(W)$ 的斜率，也就是计算 $\\frac{\\partial J(W)}{\\partial w_i}$ 在使 $J(W)$ 总体变小的方向上选定一个步长 $\\eta$ 来更新 $w_i$ 的值，然后前进到下一个点 重复以上步骤，直到 $\\frac{\\partial J(W)}{\\partial W}$ 收敛，此时斜率为零，达到值局部最小的位置。 Gradient Descent 的算法描述为 Backpropagation 参考资料： Backpropagation Understanding Backpropagation Algorithm Neural Networks from Scratch 接下来关注 $\\frac{\\partial J(W)}{\\partial W}$ 具体的计算过程，在这个过程中使用了一种叫 Backpropagation 的方法【 Backpropagation 是机器之所以能够 “学习” 的核心，因此需要重点掌握 】。 公式推导过程 考虑下面这样一个经过简化后的神经网络模型： 在这个模型中，输入为 $x_1$ 和 $x_2$，预测结果为 $y_1$ 和 $y_2$。实际的真实值为 $T_1$ 和 $T_2$ 。Activation Function 使用 Sigmoid 函数 $g(x) = \\frac{1}{1 + e^{-x}}$。 Loss Function 使用 Mean squared error loss： $J(W) = \\frac{1}{n} \\sum_{i=1}^{n} (y^{(i)} - f(x^{(i)}, W))^2$。 在推导公式之前，先复习一下 Chain Rule ： 首先，从正向来看： [\\begin{align} &amp; \\text y_1 = g( z_{2,1} ) = g( g( z_{1,1} ) \\times w_5 + g( z_{1,2} ) \\times w_6 ) \\\\ &amp; \\text y_1 = g( g( x_1 \\times w_1 + x_2 \\times w_2 ) \\times w_5 + g( x_1 \\times w_3 + x_2 \\times w_4 ) \\times w_6 ) \\\\ &amp; \\text {} \\\\ &amp; \\text y_2 = g( z_{2,2} ) = g( g( z_{1,1} ) \\times w_7 + g( z_{1,2} ) \\times w_8 ) \\\\ &amp; \\text y_2 = g( g( x_1 \\times w_1 + x_2 \\times w_2 ) \\times w_7 + g( x_1 \\times w_3 + x_2 \\times w_4 ) \\times w_8 ) \\\\ \\end{align}] 因此可以很容易得到 Loss Function $J(W)$： [\\begin{align} &amp; \\text J(W) = \\frac{1}{2} (T_1 - y_1)^2 + \\frac{1}{2} (T_2 - y_2)^2 \\end{align}] 接下来，先求 $\\frac{\\partial J(W)}{w_5}$，由 chain Rule 可得： [\\begin{align} &amp; \\text {} \\frac{\\partial J(W)}{\\partial w_5} = \\frac{\\partial J(W)}{\\partial y_1} \\times \\frac{\\partial y_1}{\\partial Z_(2,1)} \\times \\frac{\\partial Z_(2,1)}{\\partial w_5} \\\\ &amp; \\text {} \\frac{\\partial J(W)}{\\partial w_5} = ( y_1 - T_1 ) \\times g(Z_{2,1}) \\times (1 - g(Z_{2,1})) \\times g(Z_{1,1}) \\\\ \\end{align}] 同理，可求得 $\\frac{\\partial J(W)}{w_6}$、 $\\frac{\\partial J(W)}{w_7}$、 $\\frac{\\partial J(W)}{w_8}$ 。 接下来，再求 $\\frac{\\partial (W)}{w_1}$，由 chain Rule 可得： [\\begin{align} &amp; \\text {} \\frac{\\partial J(W)}{\\partial w_1} = \\frac{\\partial J(W)}{\\partial Z_{1,1}} \\times \\frac{\\partial Z_{1,1}}{\\partial w_1} \\\\ &amp; \\text {} \\frac{\\partial J(W)}{\\partial w_1} = \\frac{\\partial J(W)}{\\partial g(Z_{1,1})} \\times \\frac{\\partial g(Z_{1,1})}{\\partial Z_{1,1}} \\times \\frac{\\partial Z_{1,1}}{\\partial w_1} \\\\ \\end{align}] 其中： [\\begin{align} \\text {} \\frac{\\partial J(W)}{\\partial g(Z_{1,1})} &amp;= \\frac{\\partial J(W)}{\\partial y_1} \\times \\frac{\\partial y_1}{\\partial g(Z_{1,1})} \\\\ &amp;+ \\frac{\\partial J(W)}{\\partial y_2} \\times \\frac{\\partial y_2}{\\partial g(Z_{1,1})} \\\\ {} \\\\ \\text {} \\frac{\\partial J(W)}{\\partial g(Z_{1,1})} &amp;= \\frac{\\partial J(W)}{\\partial y_1} \\times \\frac{\\partial y_1}{\\partial Z_{2,1}} \\times \\frac{\\partial Z_{2,1}}{\\partial g(Z_{1,1})} \\\\ &amp;+ \\frac{\\partial J(W)}{\\partial y_2} \\times \\frac{\\partial y_2}{\\partial Z_{2,2}} \\times \\frac{\\partial Z_{2,2}}{\\partial g(Z_{1,1})} \\\\ {} \\\\ \\text {} \\frac{\\partial J(W)}{\\partial g(Z_{1,1})} &amp;= (y_1 - T_1) \\times g(Z_{2,1}) \\times (1 - g(Z_{2,1})) \\times w_5 \\\\ &amp;+ (y_2 - T_2) \\times g(Z_{2,2}) \\times (1 - g(Z_{2,2})) \\times w_7 \\\\ \\end{align}] 最终合在一起就是： [\\begin{align} \\text {} \\frac{\\partial J(W)}{\\partial w_1} &amp;= ((y_1 - T_1) \\times g(Z_{2,1}) \\times (1 - g(Z_{2,1})) \\times w_5 \\\\ &amp; + (y_2 - T_2) \\times g(Z_{2,2}) \\times (1 - g(Z_{2,2})) \\times w_7) \\times g(Z_{1,1}) \\times (1 - g(Z_{1,1})) \\times x_1) \\end{align}] 同理，可求得 $\\frac{\\partial J(W)}{w_2}$、 $\\frac{\\partial J(W)}{w_3}$、 $\\frac{\\partial J(W)}{w_4}$ 。 事实上，对于任意一个神经元节点来说： 都有： [\\begin{align} &amp; \\text {} \\frac{\\partial J(W)}{\\partial Z_{t,i}} = g(Z_{t,i}) \\times \\sum_{k=i}^{j} w_{t+1, k} \\frac{\\partial J(W)}{\\partial Z_{t+1,k}} \\\\ \\end{align}] 这也就是为什么这个操作叫 Backpropagation 的原因。 Python 代码实现 以下是使用 Python 代码重现了 Backpropagation 的过程。 import numpy as np def sigmoid(a): return 1 / (1 + np.exp(-a)) def diff_sigmoid(a): return ( 1 - sigmoid(a)) * sigmoid(a) def loss_function(actual, predict): return np.sum( ( ( actual - predict ) ** 2 ) / 2 ) def p_JW_of_H(layer, row_num): if layer == max_layer: return (y[row_num] - t[row_num]) * diff_sigmoid(A[layer - 1][row_num]) else: out = 0 m = A[layer - 1].shape[0] for i in range(m): out += p_JW_of_H(layer+1, row_num) * W[layer][row_num, i] * diff_sigmoid(A[layer - 1][row_num]) return out def p_JW_of_W(row_num, col_num, layer): return p_JW_of_H(layer, row_num) * X[layer - 1][col_num] x1 = np.array([[0.05], [0.10]]) w1 = np.array([[0.15, 0.20], [0.25, 0.30]]) a1 = w1.dot(x1) x2 = sigmoid(a1) w2 = np.array([[0.40, 0.45], [0.50, 0.55]]) a2 = w2.dot(x2) y = sigmoid(a2) t = np.array([0.01, 0.99]) X = [x1, x2] A = [a1, a2] W = [w1, w2] eta = 0.01 for _ in range(10000): for l in range(len(X)): for r in range(W[l].shape[0]): for c in range(W[l].shape[1]): W[l][r, c] = W[l][r, c] - eta * p_JW_of_W(r, c, l + 1) A[0] = W[0].dot(X[0]) X[1] = sigmoid(A[0]) A[1] = W[1].dot(X[1]) y = sigmoid(A[1]) 神经网络优化实践 现实中的神经网络训练往往是一个很让人头疼的问题，抛开数据量很大，计算复杂这一点。另一方面的问题是在 Gradient Descent 算法中步长 $\\eta$ 选择上。选择的步长过大，会导致结果轻易越过 W 的局部最优，离预期差十万八千里。选择的步长过小，会导致每一次的迭代中 W 的值几乎没有变化，需要浪费大量的时间和计算资源才能得到预期结果。 针对这一问题，最先想到的解决办法自然就是尝试不同的步长值，试出一种时间和计算资源成本不高且最终结果良好的步长值。采用这种方式的一个最主要的问题是缺乏通用性，每一次训练新的模型都需要经历同样的试验步长的步骤。 另一种可能的解决办法是不使用固定的步长，而是根据 Gradient 的大小、学习时间的长短、权重 W 的数量等因素设计一套算法，能够在每次迭代过程中自动选择最佳步长。实际上，类似 tensorflow 这样的框架里已经集成了一些实现上述目标的算法，像是：SGD、 Adam、 Adadelta 等等。 Mini-batches 正如同前面提到的，现实中使用的神经网络结构一般都十分复杂。要在百万次级别的迭代中计算全部数据的 Loss Function J(W) 对权重 W 的偏微分是一件极其困难的事。换个角度讲，也可以说是一件极其低效率的事，毕竟在每一次的迭代中我们期望的实际上是权重 W 向理想中的值靠近一点点。那么，更 “经济” 的做法是使用 Stochastic Gradient Descent，也就是说，每次从训练的样本中随机挑选 n 个，计算这些样本 Gradient 的平均值，将得到的平均值带入后续的计算中，指导权重 W 的更新。 过拟合的问题 所谓的过拟合，是指模型结构过于复杂，在对训练样本的预测结果变现异常完美，但面对新数据时却表现的一塌糊涂。 解决这个问题有两种思路，一种方法是 Dropout，在每次迭代的过程中随机将部分（一般是 50%） 中间隐藏层神经元的输出设置为零，以此来避免其中单独某一个节点对输出结果产生决定性影响。 另一种方法是 Early Stopping，也就是在过拟合问题出现之前提前停止训练。在每次训练过程中，把数据按比例（通常是 4:1）拆分成两部分：训练数据和测试数据，测试数据不参与训练，只用于验证模型训练结果。在每一次的迭代中观察模型对训练数据和测试数据的表现，如果在某一时刻模型对训练数据 Loss 保持降低的同时对测试数据 Loss 有上升的趋势，说明模型可能开始出现过拟合，应该在此时停止训练。 总结 这是 6S191 系列课程的第一节课，主要简单介绍了深度学习技术的一些基础知识，包括神经元及其数学表达、神经网络如何搭建如何训练，最后围绕实际生产环境中如何提升模型训练效率和准确度的问题提供了若干解决思路。","headline":"深度学习基础","mainEntityOfPage":{"@type":"WebPage","@id":"/blogs/notes/2022/04/10/6S191-MIT-DeepLearning-L1.html"},"url":"/blogs/notes/2022/04/10/6S191-MIT-DeepLearning-L1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/assets/favicon.ico">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC&amp;display=swap">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="lane4dev">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>

<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>





































































































































<header id="site-header" class="site-header site-header-transparent" role="banner">

  <div class="header__wrapper">
    <div class="header__inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="lane4dev" src="/assets/favicon.ico" onerror="this.style.display='none'">
   lane4dev
</a>
</span><nav class="site-nav"><a class="page-link" href="/blogs/">文章</a><a class="page-link" href="/blogs/archives.html">归档</a><a class="page-link" href="/about.html">关于</a>




</nav><!-- drawer menu icon  -->
      <button onclick="onOpenDrawer(this)" class="header-menu__button header-menu__hamburger">
        <svg class="icon--svg header-menu__button-icon">
          <g fill="none" fill-rule="evenodd">
            <path d="M0 0h24v24H0z"></path>
            <path d="M4 18h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1zm0-5h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1zM3 7c0 .55.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1z" fill="currentColor"></path>
          </g>
        </svg>
      </button>
      <button onclick="onCloseDrawer(this)" class="header-menu__button header-menu__drawer-close">
        <svg class="icon--svg header-menu__button-icon">
          <g fill="none" fill-rule="evenodd">
            <path d="M0 0h24v24H0z"></path>
            <path d="M18.3 5.71a.996.996 0 0 0-1.41 0L12 10.59 7.11 5.7A.996.996 0 1 0 5.7 7.11L10.59 12 5.7 16.89a.996.996 0 1 0 1.41 1.41L12 13.41l4.89 4.89a.996.996 0 1 0 1.41-1.41L13.41 12l4.89-4.89c.38-.38.38-1.02 0-1.4z" fill="currentColor"></path>
          </g>
        </svg>
      </button>
    </div>
  </div>

  <div class="header__drawer">
    <div class="header__drawer-container">
      <ul class="header-menu__primary">
<li class="header-menu__primary-item">
          <a class="page-link" href="/blogs/">
            文章
            <svg class="icon--svg page-link__icon" aria-hidden="true">
              <g fill="none" fill-rule="evenodd">
                <path d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59a.996.996 0 0 0 0-1.41l-6.58-6.6a.996.996 0 1 0-1.41 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z" fill="currentColor"></path>
              </g>
            </svg>
          </a>
        </li>
<li class="header-menu__primary-item">
          <a class="page-link" href="/blogs/archives.html">
            归档
            <svg class="icon--svg page-link__icon" aria-hidden="true">
              <g fill="none" fill-rule="evenodd">
                <path d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59a.996.996 0 0 0 0-1.41l-6.58-6.6a.996.996 0 1 0-1.41 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z" fill="currentColor"></path>
              </g>
            </svg>
          </a>
        </li>
<li class="header-menu__primary-item">
          <a class="page-link" href="/about.html">
            关于
            <svg class="icon--svg page-link__icon" aria-hidden="true">
              <g fill="none" fill-rule="evenodd">
                <path d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59a.996.996 0 0 0 0-1.41l-6.58-6.6a.996.996 0 1 0-1.41 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z" fill="currentColor"></path>
              </g>
            </svg>
          </a>
        </li>
</ul>

      <ul class="header-menu__language">




</ul>
    </div>
    <div class="wrapper">
      <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2022 Tang Yu</div>
        <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
        generator." href="http://jekyllrb.com/">Jekyll</a> &amp; Based on <a title="Yat, yet
        another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
        <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
      </div>
    </div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function (e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);

  function onOpenDrawer() {
    var documentElement = document.documentElement;
    var siteHeaderElement = document.getElementById('site-header');if (documentElement.getAttribute("data-scroll-status") == "top") {
      siteHeaderElement.classList.remove('site-header-transparent')
    }siteHeaderElement.classList.add('header--nav-open');
    documentElement.classList.add('global-disable-scroll');
  }

  function onCloseDrawer() {
    var documentElement = document.documentElement;
    var siteHeaderElement = document.getElementById('site-header');if (documentElement.getAttribute("data-scroll-status") == "top") {
      siteHeaderElement.classList.add('site-header-transparent')
    }siteHeaderElement.classList.remove('header--nav-open');
    documentElement.classList.remove('global-disable-scroll');
  }
</script>


























































































































































<style>html .page-banner {
      height:  36.8vh;
      min-height: 100vh;
    }
    html[data-scroll-status="top"] .page-banner {
      height: 100vh;
    }
  </style>
<style>
    html .page-banner .page-banner-img > *:first-child {
      opacity: 0.618;
    }

    html[data-theme="dark"] .page-banner .page-banner-img > *:first-child {
      opacity: 0.443724;
    }
  </style>
<section class="page-banner">
    <div class="page-banner-img">
<div style="background-image: url(/assets/images/2022/04/10/banner.png)"></div>
        <img class="img-placeholder" src="/assets/images/2022/04/10/banner.png">
</div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">深度学习基础</h1>
  <h2 class="post-subtitle">6S191 MIT DeepLearning Lecture 1 课程笔记</h2>

  <p class="post-meta">
    <time class="dt-published" datetime="2022-04-10T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 10, 2022
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 30 mins</span>
  </p>
<div class="post-tags">
<a class="post-tag" href="/blogs/tags.html#Deep%20Learning">#Deep Learning</a><a class="post-tag" href="/blogs/tags.html#MIT%20OpenCourseWare">#MIT OpenCourseWare</a>
</div></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      const atPositionTop = window.scrollY > 100;
      const atPositionBottom = (window.innerHeight + window.scrollY) < (document.body.offsetHeight - 100);
      if (atPositionTop && atPositionBottom) {
        clickToTop.classList.add('show')
      } else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

    <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <p>这篇文章是 6S191 MIT DeepLearning 系列课程第一课的笔记总结，我以原有课程内容为脉络，参考了李宏毅老师的课程和其他一些资料，在 Activation Function 的数学意义、 Backpropagation 过程的推导等这些自己感兴趣的话题作出了横向扩展，希望更进一步加深对深度学习的理解。深度学习在近些年发展迅速，而 MIT 6S191 DeepLearning 作为一门每年都会更新的介绍深度学习的入门类课程，在保持着极高的时效性同时，还拥有极高的课程质量，是不可多得的学习资料。</p>

<h2 id="什么是-深度学习-">什么是 “深度学习” ？</h2>
<p>在文章的一开始需要理清楚几个基本的概念，分别是：“人工智能”、“机器学习” 和 “深度学习”。这几个概念在大众的认知中常常被有意或无意的混为一谈。<br>
首先，<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a> 这一概念是 1956 年由约翰·麦卡锡等计算机科学家在 <a href="https://zh.wikipedia.org/wiki/%E8%BE%BE%E7%89%B9%E7%9F%9B%E6%96%AF%E4%BC%9A%E8%AE%AE">达特矛斯会议</a> 上提出。由于意识到计算机科学巨大的发展潜力，当时的科学家提出了一种构想，即：是否有可以找到一种方法通过计算机来模拟人类的智力活动？多年后的今天，<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a> 对这个问题给出了其中一种答案。机器学习使用了统计学方法，针对特定问题，通过海量样本数据进行数学建模，发现这些数据的内在规律，并且利用发现的规律解决相似问题。而 <a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0">深度学习</a> 又是机器学习的一个分支，是以 <a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">人工神经网络</a> 的架构对样本数据建模的一种方法。<br>
从概念上来看，三者是相互包含的关系。“人工智能” 包含了 “机器学习”，“机器学习” 又包含了 “深度学习”。<br>
<img src="/assets/images/2022/04/10/2RwctP_VTHKLPG_KVDb_dm8zmoJTuKdParnrzEa3Td3d-TVkkfXkklnIArZglrrFNZHXpablbFFjRw15FADn58z8nsUxZY5Roecnn2JLWfY3zqfhkS-BAucWWzeBkb5W.png" alt="人工智能_vs_机器学习_vs_深度学习"></p>

<h2 id="为什么需要机器学习">为什么需要机器学习</h2>
<p>传统计算机程序只能通过 <code class="language-plaintext highlighter-rouge">if ... else</code> 这样的条件判断，或是 <code class="language-plaintext highlighter-rouge">for / while</code> 这样的循环以一种线性的方式来处理问题。但是像是人脸识别、语音识别这一类的问题，没办法用传统的线性编程手段一步一步实现，我们迫切的需要一种新的算法来解决这些更加 “抽象” 的问题。</p>

<h2 id="为什么是现在">为什么是现在</h2>
<p><img src="/assets/images/2022/04/10/gCb3x47M72emg0WR5bk9Gm146z5ih_lcS5P82WKGdbtXQlQKcbTFzHmqGtKXEfvcupPrQt-_eY0KCb7r7dnZ0Alhm08WsvK8_Sxox9mykAO0V2jFsoZ-tOkuTo9TwCwe.png" alt="为什么现在是进行机器学习的好时候"></p>
<ol>
  <li>互联网的爆炸式发展已经积累起海量数据，为机器学习的算法研究提供数据支撑</li>
  <li>硬件的快速迭代，尤其是显卡算力的高速增长为机器学习的程序运算提供硬件支撑</li>
  <li>配套软件诸如 scikit-learn 、pytorch、tenserflow 这样的支撑机器学习的软件已经比较成熟，为机器学习的程序运算提供了软件支撑</li>
</ol>

<h2 id="神经元the-perceptron">神经元（The Perceptron）</h2>
<h3 id="深度学习是基于对人类神经系统的模拟">深度学习是基于对人类神经系统的模拟</h3>
<p>关于人类大脑的神经网络是如何运作的，参考以下内容：</p>
<ul>
  <li><a href="https://www.youtube.com/watch?v=HA7GwKXfJB0&ab_channel=TED">TED Speech Sebastian Seung: I am my connectome</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Computational_neuroscience">Wikipedia: Computational neuroscience</a></li>
</ul>

<h3 id="神经元的数学表达">神经元的数学表达</h3>
<ul>
  <li>单个神经元由这样几部分组成： <strong>输入</strong>、<strong>权重</strong>、<strong>求和函数</strong>、<strong>Activation Function</strong> 和 <strong>输出</strong>。<br>
<img src="/assets/images/2022/04/10/YjtXa6x_-rzo-TRbBVJ7IAWQ0eQUz0i3eFKas7DUFtmYD7u4aVlt8LuJZH0tcc_NanI-IGAvUZmXmNL8sLe4BJFl0v8Tj0HZ-kvUKVc74Q_rSCFxlHdNn6ifTnkLWXUi.png" alt="单个神经元的数学表达">
</li>
  <li>具体计算的过程是这样：
    <ul>
      <li>对 $m + 1$ 个输入 $x_0(x_0 = 1), x_1 … x_m$</li>
      <li>分别乘以各自的权重 $w_0, w_1 … w_m$</li>
      <li>把得到的结果通过求和函数相加</li>
      <li>之后再传递给 Activation Function 最终得到一个输出 $\hat{y}$</li>
    </ul>
  </li>
  <li>数学公式可以表达为：<br>
<img src="/assets/images/2022/04/10/swMGz3n8zFhuAIDierQ64I7aKcq3iDzCIstdy5Xv5W5wUhHJUgsVKwEPEo4zE_t3DI8nkua4cLadChvnxQq30FwCG6JmEUfEN1Bwla3-M46W-JOA7sURlbyfJuAMXI_X.png" alt="神经元的数学公式可以表达">
</li>
  <li>用矩阵的方式来表示数学公式： <br>
<img src="/assets/images/2022/04/10/A1TEieRfE7jie6S96rJimW4K-wfzMD7RE95OdK0O2dY3wyOXh021SNCQnivx2A9UIcxcr_Zbfs1A8dMu5nbp7thZnoYXrgE-J75qe4_IBDZKm5uTlDbv2FO-79cPDdGi.png" alt="用矩阵的方式来表示神经元的数学公式">
</li>
  <li>考虑激活函数后的完整式子<br>
<img src="/assets/images/2022/04/10/yzznkUc9JiYAB9qAh2AneafxaYlZ6_DViSkgwWTghDVZBMMCuNtiZpMgvwqHeQL64yOG4UKZPH2IqT4w6ovK5aAvgCjVYNxsh6NtOMy6hvsatEJjCvZLQ7158zfnJ6tv.png" alt="考虑激活函数后完整神经元的式子">
</li>
</ul>

<h3 id="关于激活函数">关于激活函数</h3>
<p>激活函数事实上扮演了人类神经细胞之间信号传递时神经递质的作用。当电信号沿着突触从前一个神经细胞传递到下一个神经细胞时，在两者交界处，电信号转化成化学信号，前一个神经细胞释放的神经递质被下一个细胞接收，如果神经递质的量超过某个阈值就会引发下一个神经细胞的放电。使用激活函数也是类似的效果。</p>

<h4 id="常见的激活函数有哪些">常见的激活函数有哪些？</h4>
<p><img src="/assets/images/2022/04/10/A6tLY1Vyx1mV1MAEWnxYp99Q9lLjCOcYrzaMqktrUJ8ytuAaPdSRkvXLWsLODHaJblL2oYx62ekAxdB881PLnoEMVxVxM2_0SJq77Gb74qQZmeUN8rGMZDHXDrA0Qclo.png" alt="常见的激活函数有哪些"></p>

<h4 id="为什么要有激活函数">为什么要有激活函数？</h4>
<p>参考资料： <i class="fa fa-youtube-play" aria-hidden="true" style="color: red"></i> <a href="https://www.youtube.com/watch?v=NkOv_k7r6no&ab_channel=DeepLearningAI">Why Non-linear Activation Functions (C1W3L07)</a></p>

<p>要回答这个问题，不妨先换个思路。思考另一个问题：</p>
<blockquote>
  <p><strong>如果没有激活函数会怎么样？</strong></p>
</blockquote>

<ul>
  <li>对一个两层的神经网络，我们能得到以下公式：</li>
</ul>

<p>$$
\begin{align}
&amp; \text Z^{[1]} = W^{[1]}x + b^{[1]}  \\<br>
&amp; \text a^{[1]} = g^{[1]}(Z^{[1]})  \\<br>
&amp; \text Z^{[2]} = W^{[2]}x + b^{[2]}  \\<br>
&amp; \text a^{[2]} = g^{[2]}(Z^{[2]})  \\<br>
\end{align}
$$</p>

<ul>
  <li>
    <p>现在假设激活函数不存在，也即是在上面的式子中 $a^{[1]} = Z^{[1]}$ 和 $a^{[2]} = Z^{[2]}$</p>
  </li>
  <li>
    <p>又因为第一层是第二层的输入（ $a^{[1]}$ 等于 $a^{[2]}$ 式子中的输入 $x$ ），我们可以推导以下公式：</p>
  </li>
</ul>

<p>$$
\begin{align}
&amp; \text a^{[1]} = Z^{[1]} = W^{[1]}x + b^{[1]}  \\<br>
&amp; \text a^{[2]} = Z^{[2]} = W^{[2]}x + b^{[2]}  \\<br>
&amp; \text a^{[2]} = W^{[2]}(W^{[1]}x + b^{[1]}) + b^{[2]}  \\<br>
&amp; \text a^{[2]} = W^{[2]}W^{[1]}x + W^{[2]}b^{[1]} + b^{[2]}  \\<br>
\end{align}
$$</p>

<ul>
  <li>在上面的式子里，$W^{[2]}W^{[1]}$ 的结果可以用一个矩阵 $W^{[i]}$ 替代， $W^{[2]}b^{[1]} + b^{[2]}$ 的结果可以用另一个矩阵 $b^{[i]}$ 替代，于是就有了下面的式子：</li>
</ul>

<p>$$
a^{[2]} = W^{[i]}x = b^{[i]}
$$</p>

<p>通过以上推理过程能发现一个怎样的结论呢？ <strong>如果没有激活函数，神经网络叠再多层都没有用，因为它始终都是线性的。</strong></p>

<p>所以激活函数的作用就显而易见了： <br>
<strong>激活函数的存在为神经网络的结构引入了非线性。让它能够通过一层一层的叠加来处理复杂问题。</strong>
<img src="/assets/images/2022/04/10/buY7B7yj6oDjQDwc-_LSx-QXpdOD-fEW6vdX7fNPx6EyrycIcVl6JNdkn5-7o2ov26YbR9cwdpGXkUi9XsCIBhGqDRKa8phcrBnLdx4grkxBs1dR-xyCex6Ne5QGtg_Y.png" alt="激活函数为神经网络的结构引入了非线性"></p>

<h3 id="为什么需要有一个-w_0-">为什么需要有一个 $w_0$ ？</h3>

<p>参考资料：<a href="https://medium.com/deeper-learning/glossary-of-deep-learning-bias-cf49d9c895e2">Glossary of Deep Learning: Bias</a></p>

<h4 id="从数学的角度理解">从数学的角度理解</h4>
<p>$w_{0}$ 被称为：bias ( 偏移 )。从数学上的解释来说，bias 的作用是激活函数能左右移动，以更好的拟合数据。
<img src="/assets/images/2022/04/10/3LZNU4PjVhWLH3LKsFb5RmX7_4I9IaEle6F44CWqMf71HZFdrj9Hq81Q3osjFun7VFmpQxBNVH0jAo_tikL8728kXy3ST6wYf8cvCfgLiBDEy35x8fykAAzlyE9NeNA9.png" alt="bias 的作用"></p>

<h4 id="从更简单更符合直觉的角度理解"><strong>从更简单（更符合直觉）的角度理解</strong></h4>
<p>因为 bias 的存在，事实上决定了神经元在没有没有任何输入的情况下默认保持打开还是关闭的状态。 （或者这个神经元在多大程度上容易被打开，或容易被关闭）</p>

<h3 id="所以--这些-w-的权重是怎么算出来的">所以 …… 这些 W 的权重是怎么算出来的？</h3>
<p>简单的答案是 <a href="#h-gradient-descent">Gradient Descent</a> + <a href="#h-backpropagation">Backpropagation</a>，会在后面详细展开。</p>

<h2 id="神经网络">神经网络</h2>
<h3 id="神经元组成的网络">神经元组成的网络</h3>
<p>深度学习中的神经网络就是由这样一个一个单独神经元为基础不断叠加起来的
  <img src="/assets/images/2022/04/10/pHwVvEygwG-68h5sOWvR-KCgtukdu2OZNp06gOvvSmz3lhxapA_ZZ3XC-IjW6ezAnapVPWqAbenSb1seZfGwJVG7mChK9P3bW2itKleOr-p1MKh-jh3cdcD0kbzl2DO6.png" alt="神经网络"></p>

<p>单层神经网络<br>
  <img src="/assets/images/2022/04/10/h5E60NGn5X5K9JGywnXGvlE1uIgKts9NqQ5lx13lPAXgt0QyHVroDEbW2bzW9TQf6pZL_oVzoICEPzF93sy1n-RDNJoQpN6wD0YLNxKXXfrYdDHsqX4lIZgUbU9keHFC.png" alt="单层神经网络"></p>

<p>深度（多层）神经网络<br>
  <img src="/assets/images/2022/04/10/vKo98iX56TE3uX7S1YO-LDlkKRBUhTMXfsoEeFUpi1HSH9JtEVYd1baITJ5VorDRfHJ2rn0QyxY-SI5yPfPw0_KxwcDb7b7JDa9gnbSsjL-joJWvJ4u2xq4UyWPaqQ7O.png" alt="多层神经网络"></p>

<h3 id="评估预测结果的准确性">评估预测结果的准确性</h3>
<p>我们使用 <strong>Loss Function</strong> $J(W)$ 在给定权重值 $W$ 的情况下评估模型预测的准确性。有以下几种不同的评估方式：</p>

<h4 id="quantifying-loss">Quantifying Loss</h4>
<p>旨在预测出错时衡量预测值与实际值之间的偏差。<br>
<img src="/assets/images/2022/04/10/pqgVQJf2DhXsGixp9eeDTYzI3f1pCTJqxLL2hPw9GZ6MwKJjPB7IziRIQeKIYlJn7Kz_Cp0tCWYtI6f56kZRw8JwX6dUGs75GuAOW44QXTtX6uXGuPxOngF2Qdg2OZm3.png" alt="Quantifying Loss"></p>
<h4 id="empirical-loss">Empirical Loss</h4>
<p>衡量所有数据中预测值与实际值之间的偏差。<br>
<img src="/assets/images/2022/04/10/2qHUVpMC2hVzLQTOGm9SFmBY7aGq3aAj7z_jk4Ky01neU1BFFVUUqs3UDDr9uA2ntVWMHpvygHoGpSo2fVz_cZ9docl34wYubxNV5GImt3_KefxuEEeCYoOs_mE2nNbV.png" alt="Empirical Los"></p>
<h4 id="binary-cross-entropy-loss">Binary Cross Entropy Loss</h4>
<p>当模型预测的结果是 0 到 1 之间的概率时，用 <strong>Binary Cross Entropy Loss</strong> 衡量预测准确性 。
<img src="/assets/images/2022/04/10/5gqcd-FZByXTI_VILd-LSFiHPDzs4pHAbsafEePnxfPliOMoolBiPQiCDVEm0a7CSKLppaCG_0IVf9XNIcjCF5A_BbNLvAvb8ipBvn-VDcHEiJXG7gX-179C1R4_jy5r.png" alt="Binary Cross Entropy Loss"></p>
<h4 id="mean-squared-error-loss">Mean Squared Error Loss</h4>
<p>一般用 <strong>Mean squared error loss</strong> 评价输出是连续值的回归类模型中实际值与预测值之间的差异。
<img src="/assets/images/2022/04/10/ygWy0zgZ1WAdOXYeNojUX7PEiFf-1f4F2b4VzbTNUFqoQFIEXFw9yn2gNaT4lTMBUKR7YxBJ8MENuKfCvNgm6M0uCc8abvS6esdHLKVxCaFwH4SH6ywWTi7fNCvuuItG.png" alt="Mean Squared Error Loss"></p>

<h2 id="训练神经网络">训练神经网络</h2>

<p>在前一部分的内容里，在假定权重 $W$ 的值已经确定的条件下介绍了神经网络的结构以及如何评估预测结果的准确性。<br>
在这一部分会重点关注神经网络中的权重 $W$ 是如何产生的。</p>

<p>理论上，我们需要找到这样一个 $W$ ，使得它在所有的数据集的预测结果上损失最小
<img src="/assets/images/2022/04/10/39j-OVLsiPsIeQu5gIfUXWCG00ug6INMorCZFk2OhPyL2TWVGWffkqEGmbX_vy-LvhfHvZ3vH3uen6U2MmVjGaXpV7dXM1_UPFiVErO4RQbKDQSsHp9U3mTz-v1q2Uol.png" alt="achieve the lowest loss"></p>

<p>如果可以把所有 $W$ 组合下对应的损失函数的值分布绘制出来，很直观的就能发现最小损失函数对应的 $w$ 值是多少（下图示范了只有两个 $w$ 的情况下情况下损失函数值域分布图 ）
<img src="/assets/images/2022/04/10/iwy-IcfibL_58w_ZJkBCeZIvkdT5TCLCi3XsI9LL2uHKxfWKAHokq1emjXv9DIEPH8MjDNsGNQJm32bqp2DAlvGkXQ4BO9X5K8FyNyr-hdWVkK6BRaotx4y2Nh0eMWBm.png" alt="损失函数值分布图"></p>

<h3 id="gradient-descent">Gradient Descent</h3>
<p>在实际应用场景里，一个普通的神经网路结构，轻轻松松就能包含上万个 $w$ 参数。想要穷举所有 $w$ 的组合即使对于现代计算机而言也是绝无可能的。更实际的做法是使用名为 <strong><a href="https://en.wikipedia.org/wiki/Gradient_descent">Gradient Descent</a></strong> 的方法，思路是这样的： 
<img src="/assets/images/2022/04/10/hUxc3mQ1NSywT6giIFvSCmHhMenT9E42eDS-rHbuLUHKupjtkHV6ue0L6oE2tyAjriK-dIWJ0mYzdzrAsFQr_UeTwMa7WuPQgntDc_NEGMOp1v-jWV3chz4wxCUugQoh.png" alt="Gradient Descent"></p>

<ul>
  <li>在一开始随机给定 $W$ 初始值</li>
  <li>对每一个 $w_i$ 分别计算它对损失函数 $J(W)$ 的斜率，也就是计算 $\frac{\partial J(W)}{\partial w_i}$</li>
  <li>在使 $J(W)$ 总体变小的方向上选定一个步长 $\eta$ 来更新 $w_i$ 的值，然后前进到下一个点</li>
  <li>重复以上步骤，直到 $\frac{\partial J(W)}{\partial W}$ 收敛，此时斜率为零，达到值局部最小的位置。</li>
</ul>

<p>Gradient Descent 的算法描述为<br>
<img src="/assets/images/2022/04/10/hyyDRw_fvLAyJTiPiYgdIkMSfH1hPqgCHE8PNCDSX8Cl2ob2cF2JifpmSISoI6njA5ERHhg6bGb1DQFBoSg5vEywO9g6SPRasJqQQBlvcx9CfLzs5_GodRW-goXvcJcb.png" alt="Gradient Descent 的算法描述"></p>

<h3 id="backpropagation">Backpropagation</h3>

<p>参考资料：</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Backpropagation">Backpropagation</a></li>
  <li><a href="https://towardsdatascience.com/understanding-backpropagation-algorithm-7bb3aa2f95fd">Understanding Backpropagation Algorithm</a></li>
  <li><a href="https://www.youtube.com/playlist?list=PLQVvvaa0QuDcjD5BAw2DxE6OF2tius3V3">Neural Networks from Scratch</a></li>
</ul>

<p>接下来关注 $\frac{\partial J(W)}{\partial W}$ 具体的计算过程，在这个过程中使用了一种叫 <strong><a href="https://en.wikipedia.org/wiki/Backpropagation">Backpropagation</a></strong> 的方法【 Backpropagation 是机器之所以能够 “学习” 的核心，因此需要重点掌握 】。</p>

<h4 id="公式推导过程">公式推导过程</h4>
<p>考虑下面这样一个经过简化后的神经网络模型：
<img src="/assets/images/2022/04/10/bDs8vBU-uU2FtIJuY1l3fdSmQ03FNA6PUtOTuhcVzdqdSvqk0ZqSLaREBT9Q6ys66ZKOz4mfqIVz3JXpee3K8Kb7_PWFKjZkbYywR4GclcgaobUafxeE8WfkonOcBCL2.jpeg" alt="简化神经网络"></p>

<p>在这个模型中，输入为 $x_1$ 和 $x_2$，预测结果为 $y_1$ 和 $y_2$。实际的真实值为 $T_1$ 和 $T_2$ 。Activation Function 使用 Sigmoid 函数 $g(x) = \frac{1}{1 + e^{-x}}$。  Loss Function 使用 Mean squared error loss： $J(W) = \frac{1}{n} \sum_{i=1}^{n} (y^{(i)} - f(x^{(i)}, W))^2$。</p>

<p>在推导公式之前，先复习一下 <a href="https://en.wikipedia.org/wiki/Chain_rule">Chain Rule</a> ：
<img src="/assets/images/2022/04/10/chapter14-2.png" alt="Chain Rule"></p>

<p>首先，从正向来看：</p>

<p>$$
\begin{align}
&amp; \text y_1 = g( z_{2,1} ) = g( g( z_{1,1} ) \times w_5 + g( z_{1,2} ) \times w_6 ) \\<br>
&amp; \text y_1 = g( g( x_1 \times w_1 + x_2 \times w_2 ) \times w_5 + g( x_1 \times w_3 + x_2 \times w_4 ) \times w_6 )  \\<br>
&amp; \text {} \\<br>
&amp; \text y_2 = g( z_{2,2} ) = g( g( z_{1,1} ) \times w_7 + g( z_{1,2} ) \times w_8 ) \\<br>
&amp; \text y_2 = g( g( x_1 \times w_1 + x_2 \times w_2 ) \times w_7 + g( x_1 \times w_3 + x_2 \times w_4 ) \times w_8 )  \\<br>
\end{align}
$$</p>

<p>因此可以很容易得到 Loss Function $J(W)$：</p>

<p>$$
\begin{align}
&amp; \text J(W) = \frac{1}{2} (T_1 - y_1)^2 + \frac{1}{2} (T_2 - y_2)^2
\end{align}
$$</p>

<p>接下来，先求 $\frac{\partial J(W)}{w_5}$，由 chain Rule 可得：</p>

<p>$$
\begin{align}
&amp; \text {} \frac{\partial J(W)}{\partial w_5} = \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial Z_(2,1)} \times \frac{\partial Z_(2,1)}{\partial w_5}  \\<br>
&amp; \text {} \frac{\partial J(W)}{\partial w_5} = ( y_1 - T_1 ) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times g(Z_{1,1}) \\<br>
\end{align}
$$</p>

<p>同理，可求得 $\frac{\partial J(W)}{w_6}$、 $\frac{\partial J(W)}{w_7}$、 $\frac{\partial J(W)}{w_8}$ 。</p>

<p>接下来，再求 $\frac{\partial (W)}{w_1}$，由 chain Rule 可得：</p>

<p>$$
\begin{align}
&amp; \text {} \frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial Z_{1,1}} \times \frac{\partial Z_{1,1}}{\partial w_1}  \\<br>
&amp; \text {} \frac{\partial J(W)}{\partial w_1} = \frac{\partial J(W)}{\partial g(Z_{1,1})} \times \frac{\partial g(Z_{1,1})}{\partial Z_{1,1}} \times \frac{\partial Z_{1,1}}{\partial w_1} \\<br>
\end{align}
$$</p>

<p>其中：</p>

<p>$$
\begin{align}
\text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial g(Z_{1,1})} \\<br>
&amp;+ \frac{\partial J(W)}{\partial y_2} \times \frac{\partial y_2}{\partial g(Z_{1,1})} \\<br>
{} \\<br>
\text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= \frac{\partial J(W)}{\partial y_1} \times \frac{\partial y_1}{\partial Z_{2,1}} \times \frac{\partial Z_{2,1}}{\partial g(Z_{1,1})} \\<br>
&amp;+ \frac{\partial J(W)}{\partial y_2} \times \frac{\partial y_2}{\partial Z_{2,2}} \times \frac{\partial Z_{2,2}}{\partial g(Z_{1,1})} \\<br>
{} \\<br>
\text {} \frac{\partial J(W)}{\partial g(Z_{1,1})} &amp;= (y_1 - T_1) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times w_5 \\<br>
&amp;+ (y_2 - T_2) \times g(Z_{2,2}) \times (1 - g(Z_{2,2})) \times w_7 \\<br>
\end{align}
$$</p>

<p>最终合在一起就是：</p>

<p>$$
\begin{align}
\text {} \frac{\partial J(W)}{\partial w_1} &amp;= ((y_1 - T_1) \times g(Z_{2,1}) \times (1 - g(Z_{2,1})) \times w_5 \\<br>
&amp; + (y_2 - T_2) \times g(Z_{2,2}) \times (1 - g(Z_{2,2})) \times w_7) \times g(Z_{1,1}) \times (1 - g(Z_{1,1})) \times x_1)
\end{align}
$$</p>

<p>同理，可求得 $\frac{\partial J(W)}{w_2}$、 $\frac{\partial J(W)}{w_3}$、 $\frac{\partial J(W)}{w_4}$ 。</p>

<p>事实上，对于任意一个神经元节点来说：
<img src="/assets/images/2022/04/10/IMG_0060.jpg" alt="任意一个神经元">
都有：</p>

<p>$$
\begin{align}
&amp; \text {} \frac{\partial J(W)}{\partial Z_{t,i}} = g(Z_{t,i}) \times \sum_{k=i}^{j} w_{t+1, k} \frac{\partial J(W)}{\partial Z_{t+1,k}} \\<br>
\end{align}
$$</p>

<p>这也就是为什么这个操作叫 <strong>Backpropagation</strong> 的原因。</p>

<h4 id="python-代码实现">Python 代码实现</h4>

<p>以下是使用 Python 代码重现了 Backpropagation 的过程。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">diff_sigmoid</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">*</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">loss_function</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predict</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span> <span class="n">actual</span> <span class="o">-</span> <span class="n">predict</span> <span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">p_JW_of_H</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">row_num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">layer</span> <span class="o">==</span> <span class="n">max_layer</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">row_num</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">row_num</span><span class="p">])</span> <span class="o">*</span> <span class="n">diff_sigmoid</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">row_num</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">p_JW_of_H</span><span class="p">(</span><span class="n">layer</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">row_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">W</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">row_num</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff_sigmoid</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">row_num</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">out</span>

<span class="k">def</span> <span class="nf">p_JW_of_W</span><span class="p">(</span><span class="n">row_num</span><span class="p">,</span> <span class="n">col_num</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p_JW_of_H</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">row_num</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">col_num</span><span class="p">]</span>


<span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.05</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.10</span><span class="p">]])</span>

<span class="n">w1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.30</span><span class="p">]])</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">w1</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>

<span class="n">x2</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

<span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.45</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">]])</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">w2</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">])</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">]</span>
<span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">]</span>

<span class="n">eta</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">W</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">W</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">-</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">p_JW_of_W</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<h2 id="神经网络优化实践">神经网络优化实践</h2>

<p>现实中的神经网络训练往往是一个很让人头疼的问题，抛开数据量很大，计算复杂这一点。另一方面的问题是在 Gradient Descent 算法中步长 $\eta$ 选择上。选择的步长过大，会导致结果轻易越过 W 的局部最优，离预期差十万八千里。选择的步长过小，会导致每一次的迭代中 W 的值几乎没有变化，需要浪费大量的时间和计算资源才能得到预期结果。<br>
针对这一问题，最先想到的解决办法自然就是尝试不同的步长值，试出一种时间和计算资源成本不高且最终结果良好的步长值。采用这种方式的一个最主要的问题是缺乏通用性，每一次训练新的模型都需要经历同样的试验步长的步骤。<br>
另一种可能的解决办法是不使用固定的步长，而是根据 Gradient 的大小、学习时间的长短、权重 W 的数量等因素设计一套算法，能够在每次迭代过程中自动选择最佳步长。实际上，类似 tensorflow 这样的框架里已经集成了一些实现上述目标的算法，像是：<code class="language-plaintext highlighter-rouge">SGD</code>、 <code class="language-plaintext highlighter-rouge">Adam</code>、 <code class="language-plaintext highlighter-rouge">Adadelta</code> 等等。<br>
<img src="/assets/images/2022/04/10/L3gMHLgTBZnj_EmsK0IKBOeUvGoL64PDg0XjJgz2ArhWxdaalydFRA7yG1sqe8cdHjugugbJlBoDCOVWyG65557Bnty6sT7f2xXqaNib-UaL2mpfQ08_n30ATLBNE_EH.png" alt="tensorflow-eta-algo"></p>

<h2 id="mini-batches">Mini-batches</h2>

<p>正如同前面提到的，现实中使用的神经网络结构一般都十分复杂。要在百万次级别的迭代中计算全部数据的 Loss Function J(W) 对权重 W 的偏微分是一件极其困难的事。换个角度讲，也可以说是一件极其低效率的事，毕竟在每一次的迭代中我们期望的实际上是权重 W 向理想中的值靠近一点点。那么，更 “经济” 的做法是使用 <strong><a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">Stochastic Gradient Descent</a></strong>，也就是说，每次从训练的样本中随机挑选 n 个，计算这些样本 Gradient 的平均值，将得到的平均值带入后续的计算中，指导权重 W 的更新。 
<img src="/assets/images/2022/04/10/Kl6rWhbj-v__EVhdM2ELeld1HDxE-oSXEz-e88fqX46Ks40WBGHxub5XRsaHaqyEnNbdBk4VKYBsAhBE7Dl4bGkdbG8x8rNcbQnCVFDUbDNkh5elbxvnXtaRzdv-ZmgO.png" alt="Stochastic Gradient Descent"></p>

<h2 id="过拟合的问题">过拟合的问题</h2>

<p>所谓的过拟合，是指模型结构过于复杂，在对训练样本的预测结果变现异常完美，但面对新数据时却表现的一塌糊涂。<br>
<img src="/assets/images/2022/04/10/UTAmbHMK5_h_YINrMDTATZp2dp9L15QJGW7ai9xjEvTwmFeOvmDTMbzTWof7gYSUoZ6_HOs1Zg90HyVDpHk5kF6wodOb6XeCXB42pKqQT_DgQHuGpq8XinaPf8jm4T0C.png" alt="过拟合">
解决这个问题有两种思路，一种方法是 <strong>Dropout</strong>，在每次迭代的过程中随机将部分（一般是 50%） 中间隐藏层神经元的输出设置为零，以此来避免其中单独某一个节点对输出结果产生决定性影响。
<img src="/assets/images/2022/04/10/PbjXv6iy17qJozb2RS2v8jQjEdHuQkEhXr9JSm1yX9mADql_TML43lm1yY3NTI6DARwWDYj8TQWL4cyhjnH7XpAkoD41xqreSCpZQ10ZQc7XzCH7X_L8wMQaoLBYsoc2.png" alt="Dropout">
另一种方法是 <strong>Early Stopping</strong>，也就是在过拟合问题出现之前提前停止训练。在每次训练过程中，把数据按比例（通常是 4:1）拆分成两部分：训练数据和测试数据，测试数据不参与训练，只用于验证模型训练结果。在每一次的迭代中观察模型对训练数据和测试数据的表现，如果在某一时刻模型对训练数据 Loss 保持降低的同时对测试数据 Loss 有上升的趋势，说明模型可能开始出现过拟合，应该在此时停止训练。
<img src="/assets/images/2022/04/10/qmljpsfEPyMIj1vonVKaE4EXgECDjFdD17fnD-qcigTl2mOmmrWLLjTBanNvgDYAX2QWdHdfEpR8wT8o68MD5s2ukXead1blWhOetjlMxUO_m3qT-qis8sLOizGNejLb.png" alt="Early Stopping"></p>

<h2 id="总结">总结</h2>

<p>这是 6S191 系列课程的第一节课，主要简单介绍了深度学习技术的一些基础知识，包括神经元及其数学表达、神经网络如何搭建如何训练，最后围绕实际生产环境中如何提升模型训练效率和准确度的问题提供了若干解决思路。</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/blogs/thoughts/2022/03/24/about-how-to-read-papers.html" title="关于如何高效阅读机器学习专业论文">关于如何高效阅读机器学习专业论文</a><span></span>
</div>
<div class="post-related">
      <div>相关文章</div>
      <ul>
        
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          </ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">目录</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div class="site-footer-text">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2022 Tang Yu</div>
        <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
        generator." href="http://jekyllrb.com/">Jekyll</a> &amp; Based on <a title="Yat, yet
        another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
        <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
      </div>
      <div class="theme-toggle-wrapper">
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
</div>
    </div>
  </div>
</footer>
</body>

</html>
